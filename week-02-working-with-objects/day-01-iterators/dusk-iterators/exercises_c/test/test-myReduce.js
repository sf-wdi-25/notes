/* This is the test file for myReduce function
 *    PLEASE DO NOT EDIT THIS FILE
 * To run these tests do `mocha spec/test-myReduce.js`
*/

var mocha = require('mocha');
var chai = require('chai');
var spies = require('chai-spies');
chai.use(spies);

var expect = chai.expect;
chai.config.includeStack = false; // turn off stack trace
chai.config.showDiff = true; // turn on reporter diff display

var myReduce = require('../myReduce');

describe('myReduce', function() {
  // sample data
  beforeEach(function() {
    testArr = ['a', 'b', 'c', 'd'];
  });

  it("takes a function as the second argument and calls that function (callback)", function testCallback() {
    function spyOnMe() {}
    var spy = chai.spy(spyOnMe);
    myReduce(testArr, spy);
    expect(spy).to.have.been.called();
  });

  it("has a return value that is equal to the last return value of the callback", function() {
    var results = myReduce(testArr, function(){
      return 1000100;  // on every pass
    });
    console.log('       results: ', results);
    expect(results).to.equal(1000100);
  });


  it("returns a single value, not an array", function() {
    var results = myReduce(testArr, function() {
      return 'mercury';
    }, 'foo');
    console.log('       results: ', results);
    expect(results).to.not.be.an('Array');
    expect(results).to.not.be.an("undefined");
  });


  it("passes the last result of the callback as the first argument to the " +
    "callback on each successive pass", function() {
    var results = [];

    myReduce(testArr, function(previousValue) {
      results.push(previousValue);
      return 'blue';
    });
    console.log('       results: ', results);
    expect(results[1]).to.equal('blue');
    results.shift(); // the previous test verified that element 0 is 192
    expect(results).to.have.members(['blue', 'blue', 'blue']);
  });


  it("passes the entire array to the callback as argument 4", function testArrayPassing() {
    var resultingArray = [];
    myReduce(testArr, function(_prev, _curr, index, arr) {
      console.log('       results: ', arr);
      // each time the callback is called verify that the array is as expected
      // Note: until the callback is called though, this test will still pass
      expect(arr).to.have.members(['a', 'b', 'c', 'd']);
    });
  });


  describe("when NO initialValue is provided", function() {

    it("it uses element 0 as the starting point (1st arg)", function() {
      var stachedValues = [];
      myReduce(['a', 0, 0, 0], function(prev, _curr) {
        stachedValues.push(prev);
        return 'x';
      });
      console.log('      results: ', stachedValues);
      expect(stachedValues[0]).to.equal('a');
    });

    it("it uses element 1 as the first currentValue (2nd argument)", function() {
      var stachedValues = [];
      myReduce([0, 'b', 0], function(_prev, curr) {
        stachedValues.push(curr);
        return 'x';
      });
      console.log('      results: ', stachedValues);
      expect(stachedValues[0]).to.equal('b');
    });

    it("passes each element as the second argument to the callback", function testEachElem() {
      var resultingArray = [];
      myReduce(testArr, function(_prev, curr) {
        resultingArray.push(curr);
      });
      // compare elements in the result to the expected array
      console.log('       results: ', resultingArray);
      // note: 'a' is the first _prev; so the first curr is 'b'
      expect(resultingArray).to.have.members(['b', 'c', 'd']);
    });

    it("passes each index in the array to the callback as the 3rd arg", function testEachIndex() {
      var resultingArray = [];
      myReduce(testArr, function(_prev, _curr, index) {
        resultingArray.push(index);
      });
      // compare elements in the result to expected array
      console.log('       results: ', resultingArray);
      // we don't include 0 because index 0 is the first _prev
      expect(resultingArray).to.have.members([1, 2, 3]);
    });

    it("the first index is 1", function() {
      var results = [];
      myReduce(testArr, function(_prev, _next, index) {
        results.push(index);
      });
      expect(results[0]).to.equal(1);
    });

  });

  describe("when an initialValue IS provided", function() {
      it("passes the initialValue in as the first argument to the callback on the first pass", function() {
        var result = [];

        myReduce(testArr, function(previousValue) {
          result.push(previousValue);
        }, 192);
        expect(result[0]).to.equal(192);
      });

      it("the first index is 0", function() {
        var results = [];
        myReduce(testArr, function(_prev, _next, index) {
          results.push(index);
        }, 'asdf');
        expect(results[0]).to.equal(0);
      });

      it("works with arrays of length 0", function testArrayL0() {
        var resultingArray = [];
        var result = myReduce([], function(item) {
          return '44';
        }, 99);
        // compare elements in the result to expected array
        console.log('       result: ', result);
        expect(result).to.equal(99);
      });

      it("never calls the callback if the array is length 0", function() {
        function spyOnMe() {}
        var spy = chai.spy(spyOnMe);

        myReduce([], spy, 11);
        expect(spy).to.not.have.been.called();
      });

  });

});
